<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹¤ì‹œê°„ ì‹œë‚˜ë¦¬ì˜¤ë³„ STT í…ŒìŠ¤íŠ¸</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
        }
        
        .scenario-section {
            margin-bottom: 30px;
        }
        
        .scenario-tabs {
            display: flex;
            margin-bottom: 20px;
        }
        
        .tab-button {
            padding: 12px 24px;
            margin-right: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .tab-button.dating {
            background: #ff6b9d;
            color: white;
        }
        
        .tab-button.interview {
            background: #4ecdc4;
            color: white;
        }
        
        .tab-button.presentation {
            background: #45b7d1;
            color: white;
        }
        
        .tab-button.active {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: inline-block;
            width: 120px;
            font-weight: bold;
            color: #4a5568;
        }
        
        select, input {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
        }
        
        button {
            padding: 12px 24px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn-start {
            background: #48bb78;
            color: white;
        }
        
        .btn-stop {
            background: #f56565;
            color: white;
        }
        
        .btn-upload {
            background: #ed8936;
            color: white;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status.connected {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #48bb78;
        }
        
        .status.disconnected {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #f56565;
        }
        
        .status.recording {
            background: #fef5e7;
            color: #744210;
            border: 2px solid #ed8936;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .results {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            min-height: 100px;
        }
        
        .transcription {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #4c51bf;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4c51bf;
        }
        
        .metric-label {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }
        
        .speed-category {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .speed-very-slow { background: #fed7d7; color: #742a2a; }
        .speed-slow { background: #fef5e7; color: #744210; }
        .speed-normal { background: #c6f6d5; color: #22543d; }
        .speed-fast { background: #bee3f8; color: #2a4365; }
        .speed-very-fast { background: #e9d8fd; color: #44337a; }
        
        .permission-section, .connection-section, .recording-section {
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            margin-bottom: 15px;
        }
        
        .permission-section {
            border-left: 4px solid #ffc107;
        }
        
        .connection-section {
            border-left: 4px solid #17a2b8;
        }
        
        .recording-section {
            border-left: 4px solid #28a745;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
        }
        
        .visualizer {
            height: 120px;
            background: linear-gradient(45deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #e9ecef;
            border-radius: 12px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .visualizer canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .log-section {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-send {
            color: #dc3545;
            font-weight: bold;
        }
        
        .log-receive {
            color: #28a745;
            font-weight: bold;
        }
        
        .log-info {
            color: #17a2b8;
        }
        
        .buffer-status {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 10px 0;
            font-size: 12px;
            color: #856404;
        }
        
        .interim {
            color: #888;
            font-style: italic;
        }
        
        .final {
            color: #000;
        }
        
        .segment {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .segment.new {
            background-color: #f1f8e9;
            animation: fadeIn 1s;
        }
        
        @keyframes fadeIn {
            from { background-color: #c8e6c9; }
            to { background-color: #f1f8e9; }
        }
        
        .upload-section {
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ™ï¸ ì‹¤ì‹œê°„ ì‹œë‚˜ë¦¬ì˜¤ë³„ STT í…ŒìŠ¤íŠ¸</h1>
        
        <div class="scenario-section">
            <div class="scenario-tabs">
                <button class="tab-button dating active" data-scenario="dating">
                    ğŸ’• ì†Œê°œíŒ…
                </button>
                <button class="tab-button interview" data-scenario="interview">
                    ğŸ’¼ ë©´ì ‘
                </button>
                <button class="tab-button presentation" data-scenario="presentation">
                    ğŸ“Š ë°œí‘œ
                </button>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>ì–¸ì–´:</label>
                    <select id="languageSelect">
                        <option value="ko">í•œêµ­ì–´</option>
                        <option value="en">English</option>
                        <option value="ja">æ—¥æœ¬èª</option>
                        <option value="zh">ä¸­æ–‡</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>ì„œë²„ URL:</label>
                    <input type="text" id="serverUrl" value="wss://stt.eumgyeol.com/api/v1/stt/stream" style="width: 300px;">
                </div>
            </div>
            
            <!-- ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë° ì„¹ì…˜ -->
            <div>
                <h3>ğŸ”´ ì‹¤ì‹œê°„ ìŒì„± ì¸ì‹</h3>
                
                <!-- ë§ˆì´í¬ ê¶Œí•œ ì„¹ì…˜ -->
                <div class="permission-section">
                    <div class="section-title">ğŸ¤ 1ë‹¨ê³„: ë§ˆì´í¬ ê¶Œí•œ</div>
                    <button id="micPermissionBtn" class="btn-start">ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</button>
                    <span id="micStatus" style="margin-left: 10px; font-size: 12px; color: #666;">ë§ˆì´í¬ ê¶Œí•œ í•„ìš”</span>
                </div>
                
                <!-- ì›¹ì†Œì¼“ ì—°ê²° ì„¹ì…˜ -->
                <div class="connection-section">
                    <div class="section-title">ğŸ”— 2ë‹¨ê³„: ì„œë²„ ì—°ê²°</div>
                    <button id="connectBtn" class="btn-start" disabled>ì„œë²„ ì—°ê²°</button>
                    <button id="disconnectBtn" class="btn-stop" disabled>ì—°ê²° í•´ì œ</button>
                    <span id="connectionStatus" style="margin-left: 10px; font-size: 12px; color: #666;">ì—°ê²° ì•ˆë¨</span>
                </div>
                
                <!-- ë…¹ìŒ ì œì–´ ì„¹ì…˜ -->
                <div class="recording-section">
                    <div class="section-title">ğŸ™ï¸ 3ë‹¨ê³„: ìŒì„± ë…¹ìŒ</div>
                    <button id="startRecordingBtn" class="btn-start" disabled>ë…¹ìŒ ì‹œì‘</button>
                    <button id="stopRecordingBtn" class="btn-stop" disabled>ë…¹ìŒ ì¤‘ì§€</button>
                    <br><br>
                    <div style="border-top: 1px solid #dee2e6; padding-top: 10px; margin-top: 10px;">
                        <div class="section-title">âš¡ ë¹ ë¥¸ ì‹œì‘</div>
                        <button id="quickStartBtn" class="btn-upload">ì›í´ë¦­ ì‹œì‘ (ëª¨ë“  ë‹¨ê³„ ìë™)</button>
                    </div>
                </div>
                
                <!-- ì˜¤ë””ì˜¤ ì‹œê°í™” ì„¹ì…˜ -->
                <div class="visualizer">
                    <canvas id="audio-visualizer"></canvas>
                </div>
                
                <!-- ë²„í¼ ìƒíƒœ í‘œì‹œ -->
                <div id="bufferStatus" class="buffer-status" style="display: none;">
                    ë²„í¼ë§ ì¤‘: <span id="bufferProgress">0/30</span>ì´ˆ (<span id="bufferSize">0</span>KB)
                </div>
                
                <!-- ì˜¤ë””ì˜¤ ì†¡ìˆ˜ì‹  ë¡œê·¸ -->
                <div class="log-section">
                    <div style="font-weight: bold; margin-bottom: 8px;">ğŸ“Š ì˜¤ë””ì˜¤ ì†¡ìˆ˜ì‹  ë¡œê·¸</div>
                    <div id="audioLog"></div>
                </div>
                
                <div id="status" class="status disconnected">ì¤€ë¹„ ì¤‘...</div>
            </div>
            
            <!-- íŒŒì¼ ì—…ë¡œë“œ ì„¹ì…˜ -->
            <div class="upload-section">
                <h3>ğŸ“ íŒŒì¼ ì—…ë¡œë“œ í…ŒìŠ¤íŠ¸</h3>
                <input type="file" id="fileInput" accept=".wav,.mp3,.ogg,.flac">
                <button id="uploadBtn" class="btn-upload">íŒŒì¼ ë¶„ì„</button>
            </div>
        </div>
        
        <div class="results" id="results">
            <h3>ğŸ“Š ë¶„ì„ ê²°ê³¼</h3>
            <div id="transcriptions"></div>
        </div>
    </div>

    <script>
        class RealtimeSTTClient {
            constructor() {
                this.ws = null;
                this.mediaStream = null;
                this.audioContext = null;
                this.processor = null;
                this.analyser = null;
                this.dataArray = null;
                this.animationId = null;
                
                this.currentScenario = 'dating';
                this.isRecording = false;
                this.isConnected = false;
                this.hasMicPermission = false;
                
                // 60ì´ˆ ë²„í¼ë§ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
                this.audioBuffer = [];
                this.audioBufferDuration = 0;
                this.bufferStartTime = null;
                this.bufferDuration = 30; // 60ì´ˆ
                this.totalAudioSent = 0;
                this.totalAudioReceived = 0;
                
                this.initializeUI();
                this.checkMicPermission();
            }
            
            initializeUI() {
                // ì‹œë‚˜ë¦¬ì˜¤ íƒ­ ì´ë²¤íŠ¸
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentScenario = e.target.dataset.scenario;
                        console.log('ì‹œë‚˜ë¦¬ì˜¤ ë³€ê²½:', this.currentScenario);
                    });
                });
                
                // ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ë²„íŠ¼
                document.getElementById('micPermissionBtn').addEventListener('click', () => this.requestMicPermission());
                
                // ì›¹ì†Œì¼“ ì—°ê²° ë²„íŠ¼
                document.getElementById('connectBtn').addEventListener('click', () => this.connectWebSocket());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnectWebSocket());
                
                // ë…¹ìŒ ì œì–´ ë²„íŠ¼
                document.getElementById('startRecordingBtn').addEventListener('click', () => this.startRecording());
                document.getElementById('stopRecordingBtn').addEventListener('click', () => this.stopRecording());
                document.getElementById('quickStartBtn').addEventListener('click', () => this.quickStart());
                
                // íŒŒì¼ ì—…ë¡œë“œ ì´ë²¤íŠ¸
                document.getElementById('uploadBtn').addEventListener('click', () => this.uploadFile());
            }
            
            async checkMicPermission() {
                try {
                    const result = await navigator.permissions.query({ name: 'microphone' });
                    if (result.state === 'granted') {
                        this.setMicPermission(true);
                    } else {
                        this.setMicPermission(false);
                    }
                    
                    result.addEventListener('change', () => {
                        this.setMicPermission(result.state === 'granted');
                    });
                } catch (error) {
                    console.log('ê¶Œí•œ API ë¯¸ì§€ì›, ìˆ˜ë™ í™•ì¸ í•„ìš”');
                    this.setMicPermission(false);
                }
            }
            
            setMicPermission(hasPermission) {
                this.hasMicPermission = hasPermission;
                const micStatus = document.getElementById('micStatus');
                const connectBtn = document.getElementById('connectBtn');
                
                if (hasPermission) {
                    micStatus.textContent = 'âœ… ë§ˆì´í¬ ê¶Œí•œ ìˆìŒ';
                    micStatus.style.color = '#22543d';
                    connectBtn.disabled = false;
                } else {
                    micStatus.textContent = 'âŒ ë§ˆì´í¬ ê¶Œí•œ í•„ìš”';
                    micStatus.style.color = '#742a2a';
                    connectBtn.disabled = true;
                }
                
                this.updateButtonStates();
            }
            
            async requestMicPermission() {
                try {
                    this.updateStatus('recording', 'ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ì¤‘...');
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    // ìŠ¤íŠ¸ë¦¼ì„ ì¦‰ì‹œ ì¢…ë£Œ (ê¶Œí•œ í™•ì¸ìš©)
                    stream.getTracks().forEach(track => track.stop());
                    
                    this.setMicPermission(true);
                    this.updateStatus('connected', 'ë§ˆì´í¬ ê¶Œí•œ íšë“ ì™„ë£Œ');
                    
                } catch (error) {
                    console.error('ë§ˆì´í¬ ê¶Œí•œ ê±°ë¶€:', error);
                    this.setMicPermission(false);
                    this.updateStatus('disconnected', 'ë§ˆì´í¬ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤');
                    alert('ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.');
                }
            }
            
            connectWebSocket() {
                if (this.isConnected) {
                    this.updateStatus('connected', 'ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤');
                    return;
                }
                
                const language = document.getElementById('languageSelect').value;
                const serverUrl = document.getElementById('serverUrl').value;
                const wsUrl = `${serverUrl}?language=${language}&scenario=${this.currentScenario}`;
                
                this.updateStatus('recording', 'ì„œë²„ ì—°ê²° ì¤‘...');
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket ì—°ê²°ë¨');
                    this.addLog('info', `ì„œë²„ ì—°ê²° ì„±ê³µ: ${wsUrl}`);
                    this.isConnected = true;
                    this.setConnectionStatus(true);
                    this.updateStatus('connected', 'ì„œë²„ ì—°ê²° ì™„ë£Œ');
                    this.updateButtonStates();
                    
                    // ì—°ê²° ìƒíƒœ ë””ë²„ê¹… ì •ë³´
                    this.addLog('info', `ì›¹ì†Œì¼“ ìƒíƒœ: ${this.ws.readyState}, í”„ë¡œí† ì½œ: ${this.ws.protocol}`);
                };
                
                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.totalAudioReceived += event.data.length;
                    this.addLog('receive', `STT ê²°ê³¼ ìˆ˜ì‹ : "${data.text?.substring(0, 50)}${data.text?.length > 50 ? '...' : ''}" | ì´ ìˆ˜ì‹ : ${(this.totalAudioReceived / 1024).toFixed(1)}KB`);
                    this.handleWebSocketMessage(data);
                };
                
                this.ws.onclose = () => {
                    console.log('WebSocket ì—°ê²° ì¢…ë£Œ');
                    this.addLog('info', 'WebSocket ì—°ê²° ì¢…ë£Œ');
                    this.isConnected = false;
                    this.setConnectionStatus(false);
                    this.updateStatus('disconnected', 'ì„œë²„ ì—°ê²° ì¢…ë£Œ');
                    this.updateButtonStates();
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket ì˜¤ë¥˜:', error);
                    this.addLog('info', 'WebSocket ì—°ê²° ì˜¤ë¥˜');
                    this.isConnected = false;
                    this.setConnectionStatus(false);
                    this.updateStatus('disconnected', 'ì„œë²„ ì—°ê²° ì˜¤ë¥˜');
                    this.updateButtonStates();
                };
            }
            
            disconnectWebSocket() {
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                this.isConnected = false;
                this.setConnectionStatus(false);
                this.updateStatus('disconnected', 'ì„œë²„ ì—°ê²° í•´ì œë¨');
                this.updateButtonStates();
            }
            
            setConnectionStatus(isConnected) {
                const connectionStatus = document.getElementById('connectionStatus');
                
                if (isConnected) {
                    connectionStatus.textContent = 'âœ… ì„œë²„ ì—°ê²°ë¨';
                    connectionStatus.style.color = '#22543d';
                } else {
                    connectionStatus.textContent = 'âŒ ì„œë²„ ì—°ê²° ì•ˆë¨';
                    connectionStatus.style.color = '#742a2a';
                }
            }
            
            async startRecording() {
                if (!this.isConnected) {
                    alert('ë¨¼ì € ì„œë²„ì— ì—°ê²°í•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                if (this.isRecording) {
                    this.updateStatus('recording', 'ì´ë¯¸ ë…¹ìŒ ì¤‘ì…ë‹ˆë‹¤');
                    return;
                }
                
                try {
                    this.updateStatus('recording', 'ë§ˆì´í¬ í™œì„±í™” ì¤‘...');
                    
                    // ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ ìƒì„±
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    // AudioContext ì„¤ì •
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = this.audioContext.createMediaStreamSource(this.mediaStream);
                    
                    // ì‹¤ì‹œê°„ ì˜¤ë””ì˜¤ ì²˜ë¦¬ë¥¼ ìœ„í•œ ScriptProcessor
                    this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);
                    
                    this.processor.onaudioprocess = (event) => {
                        if (!this.isRecording) return;
                        
                        const inputBuffer = event.inputBuffer;
                        const inputData = inputBuffer.getChannelData(0);
                        
                        // 16kHzë¡œ ë‹¤ìš´ìƒ˜í”Œë§ (Whisper ëª¨ë¸ ìš”êµ¬ì‚¬í•­)
                        const targetSampleRate = 16000;
                        const resampledData = this.downsampleAudio(inputData, this.audioContext.sampleRate, targetSampleRate);
                            
                        // Float32Arrayë¥¼ Int16Arrayë¡œ ë³€í™˜ (16-bit PCM)
                        const pcmData = this.convertFloatTo16BitPCM(resampledData);
                        
                        // 60ì´ˆ ë²„í¼ì— ì¶”ê°€
                        this.addToBuffer(pcmData, resampledData.length / targetSampleRate);
                        
                        // ë²„í¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                        this.updateBufferStatus();
                    };
                    
                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);
                    
                    // ì˜¤ë””ì˜¤ ì‹œê°í™” ì„¤ì •
                    this.setupAudioVisualization(source);
                    
                    this.isRecording = true;
                    
                    // ì„œë²„ì— ë…¹ìŒ ì‹œì‘ ëª…ë ¹ ì „ì†¡
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({command: "start_recording"}));
                        this.addLog('send', 'ë…¹ìŒ ì‹œì‘ ëª…ë ¹ ì „ì†¡');
                    }
                    
                    this.updateStatus('recording', 'ë…¹ìŒ ì¤‘...');
                    this.updateButtonStates();
                    
                } catch (error) {
                    console.error('ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜:', error);
                    this.updateStatus('disconnected', 'ë…¹ìŒ ì‹œì‘ ì‹¤íŒ¨');
                    alert('ë§ˆì´í¬ ì ‘ê·¼ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
            
            setupAudioVisualization(source) {
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                const bufferLength = this.analyser.frequencyBinCount;
                this.dataArray = new Uint8Array(bufferLength);
                
                source.connect(this.analyser);
                this.startVisualization();
            }
            
            startVisualization() {
                const canvas = document.getElementById('audio-visualizer');
                if (!canvas || !this.analyser) return;
                
                const canvasCtx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                let animationTime = 0;
                
                const draw = () => {
                    if (!this.isRecording) return;
                    
                    this.animationId = requestAnimationFrame(draw);
                    animationTime += 0.1;
                    
                    this.analyser.getByteFrequencyData(this.dataArray);
                    
                    // ê·¸ë¼ë°ì´ì…˜ ë°°ê²½
                    const gradient = canvasCtx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(1, '#764ba2');
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / this.dataArray.length) * 3;
                    let x = 0;
                    
                    for (let i = 0; i < this.dataArray.length; i++) {
                        const barHeight = (this.dataArray[i] / 255) * canvas.height * 0.8;
                        
                        // ë¬´ì§€ê°œ ìƒ‰ìƒ íš¨ê³¼
                        const hue = (i / this.dataArray.length) * 360 + animationTime * 2;
                        const saturation = 70 + (this.dataArray[i] / 255) * 30;
                        const lightness = 50 + (this.dataArray[i] / 255) * 40;
                        
                        canvasCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                        
                        // ë‘¥ê·¼ ëª¨ì„œë¦¬ íš¨ê³¼
                        canvasCtx.beginPath();
                        canvasCtx.roundRect(x, canvas.height - barHeight, barWidth - 2, barHeight, 3);
                        canvasCtx.fill();
                        
                        // ë°œê´‘ íš¨ê³¼
                        canvasCtx.shadowColor = canvasCtx.fillStyle;
                        canvasCtx.shadowBlur = 10;
                        canvasCtx.fill();
                        canvasCtx.shadowBlur = 0;
                        
                        x += barWidth;
                    }
                    
                    // ìƒë‹¨ì— íŒŒí˜• ì˜¤ë²„ë ˆì´
                    this.analyser.getByteTimeDomainData(this.dataArray);
                    canvasCtx.strokeStyle = '#ffffff';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.beginPath();
                    
                    const sliceWidth = canvas.width / this.dataArray.length;
                    x = 0;
                    
                    for (let i = 0; i < this.dataArray.length; i++) {
                        const v = this.dataArray[i] / 128.0;
                        const y = v * canvas.height / 4 + canvas.height / 8;
                        
                        if (i === 0) {
                            canvasCtx.moveTo(x, y);
                        } else {
                            canvasCtx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    canvasCtx.stroke();
                };
                
                draw();
            }
            
            stopRecording() {
                if (!this.isRecording) {
                    this.updateStatus('connected', 'ë…¹ìŒ ì¤‘ì´ ì•„ë‹™ë‹ˆë‹¤');
                    return;
                }
                
                this.isRecording = false;
                
                // ë‚¨ì€ ë²„í¼ ë°ì´í„° ì „ì†¡ (ë…¹ìŒ ì¤‘ì§€ ëª…ë ¹ ì „ì—)
                this.sendBufferedAudio(true);
                
                // ì„œë²„ì— ë…¹ìŒ ì¤‘ì§€ ëª…ë ¹ ì „ì†¡ (ë°ì´í„° ì „ì†¡ í›„)
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({command: "stop_recording"}));
                    this.addLog('send', 'ë…¹ìŒ ì¤‘ì§€ ëª…ë ¹ ì „ì†¡');
                }
                
                // ì‹œê°í™” ì •ì§€
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                // AudioContext ì •ë¦¬
                if (this.processor) {
                    this.processor.disconnect();
                    this.processor = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                // ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¼ ì •ì§€
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                
                // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                const canvas = document.getElementById('audio-visualizer');
                if (canvas) {
                    const canvasCtx = canvas.getContext('2d');
                    const gradient = canvasCtx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#f8f9fa');
                    gradient.addColorStop(1, '#e9ecef');
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                // ë²„í¼ ìƒíƒœ ìˆ¨ê¹€
                document.getElementById('bufferStatus').style.display = 'none';
                
                // ìµœì¢… ì²˜ë¦¬ ìš”ì²­
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({command: "process_final"}));
                    this.addLog('send', 'ìµœì¢… ì²˜ë¦¬ ìš”ì²­ ì „ì†¡');
                }
                
                this.updateStatus('connected', 'ë…¹ìŒ ì™„ë£Œ');
                this.updateButtonStates();
            }
            
            addToBuffer(pcmData, audioDuration) {
                if (!this.bufferStartTime) {
                    this.bufferStartTime = Date.now();
                    this.audioBufferDuration = 0;
                    document.getElementById('bufferStatus').style.display = 'block';
                    this.addLog('info', `30ì´ˆ ë²„í¼ë§ ì‹œì‘ - PCM ë°°ì—´ ê¸¸ì´: ${pcmData.length}, ì˜¤ë””ì˜¤ ê¸¸ì´: ${audioDuration.toFixed(3)}ì´ˆ`);
                }
                
                this.audioBuffer.push(pcmData);
                this.audioBufferDuration += audioDuration;
                
                // ë””ë²„ê¹…ìš© ë¡œê·¸ (ë§¤ 100ê°œ chunkë§ˆë‹¤)
                if (this.audioBuffer.length % 100 === 0) {
                    this.addLog('info', `ë²„í¼ ìƒíƒœ: ${this.audioBuffer.length}ê°œ ì²­í¬, ì´ ${this.audioBufferDuration.toFixed(1)}ì´ˆ`);
                }
                
                // ì˜¤ë””ì˜¤ ê¸°ì¤€ 30ì´ˆê°€ ë˜ë©´ ì „ì†¡
                if (this.audioBufferDuration >= this.bufferDuration) {
                    this.sendBufferedAudio();
                }
            }
            
            downsampleAudio(audioBuffer, sourceSampleRate, targetSampleRate) {
                if (sourceSampleRate === targetSampleRate) {
                    return audioBuffer;
                }
                
                const ratio = sourceSampleRate / targetSampleRate;
                const newLength = Math.round(audioBuffer.length / ratio);
                const result = new Float32Array(newLength);
                
                // ë‹¨ìˆœí•œ ì„ í˜• ë³´ê°„ì„ ì‚¬ìš©í•œ ë‹¤ìš´ìƒ˜í”Œë§
                for (let i = 0; i < newLength; i++) {
                    const position = i * ratio;
                    const index = Math.floor(position);
                    const fraction = position - index;
                    
                    // ì„ í˜• ë³´ê°„
                    if (index + 1 < audioBuffer.length) {
                        result[i] = audioBuffer[index] * (1 - fraction) + audioBuffer[index + 1] * fraction;
                    } else {
                        result[i] = audioBuffer[index];
                    }
                }
                
                return result;
            }
            
            convertFloatTo16BitPCM(float32Array) {
                const l = float32Array.length;
                const pcm16bit = new Int16Array(l);
                
                for (let i = 0; i < l; i++) {
                    // í´ë¦¬í•‘ ë°©ì§€
                    const s = Math.max(-1, Math.min(1, float32Array[i]));
                    // -32768 ~ 32767 ë²”ìœ„ë¡œ ë³€í™˜
                    pcm16bit[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
                
                return pcm16bit;
            }
            
            sendBufferedAudio(isFinal = false) {
                if (this.audioBuffer.length === 0) return;
                
                // WebSocketìœ¼ë¡œ ì „ì†¡ - Int16Array ë°°ì—´ì„ í•˜ë‚˜ì˜ ArrayBufferë¡œ í•©ì¹˜ê¸°
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    // ëª¨ë“  Int16Array ë°°ì—´ì˜ ì´ ê¸¸ì´ ê³„ì‚°
                    const totalLength = this.audioBuffer.reduce((sum, buffer) => sum + buffer.length, 0);
                    
                    // ìƒˆë¡œìš´ Int16Array ìƒì„±í•˜ì—¬ ëª¨ë“  ë°ì´í„° í•©ì¹˜ê¸°
                    const combinedArray = new Int16Array(totalLength);
                    let offset = 0;
                    
                    for (const buffer of this.audioBuffer) {
                        combinedArray.set(buffer, offset);
                        offset += buffer.length;
                    }
                    
                    // ArrayBufferë¡œ ë³€í™˜í•˜ì—¬ ì „ì†¡
                    const audioData = combinedArray.buffer;
                    this.ws.send(audioData);
                    
                    const sizeKB = (audioData.byteLength / 1024).toFixed(1);
                    const duration = this.audioBufferDuration.toFixed(1);
                    this.totalAudioSent += audioData.byteLength;
                    
                    this.addLog('send', `ì˜¤ë””ì˜¤ ë°ì´í„° ì „ì†¡: ${duration}ì´ˆ (${sizeKB}KB, ${totalLength} samples) | ì´ ì „ì†¡: ${(this.totalAudioSent / 1024 / 1024).toFixed(1)}MB`);
                }
                
                // ë²„í¼ ì´ˆê¸°í™”
                this.audioBuffer = [];
                this.audioBufferDuration = 0;
                this.bufferStartTime = isFinal ? null : Date.now();
                
                if (!isFinal) {
                    this.addLog('info', 'ìƒˆë¡œìš´ 30ì´ˆ ë²„í¼ë§ ì‹œì‘');
                }
            }
            
            updateBufferStatus() {
                if (!this.bufferStartTime) return;
                
                const progress = Math.min(this.audioBufferDuration, this.bufferDuration);
                const totalBytes = this.audioBuffer.reduce((sum, buffer) => sum + buffer.byteLength, 0);
                const sizeKB = (totalBytes / 1024).toFixed(1);
                
                document.getElementById('bufferProgress').textContent = `${progress.toFixed(1)}/${this.bufferDuration}`;
                document.getElementById('bufferSize').textContent = sizeKB;
            }
            
            addLog(type, message) {
                const logContainer = document.getElementById('audioLog');
                const timestamp = new Date().toLocaleTimeString();
                
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                
                let prefix = '';
                switch(type) {
                    case 'send': prefix = 'ğŸ“¤ '; break;
                    case 'receive': prefix = 'ğŸ“¥ '; break;
                    case 'info': prefix = 'â„¹ï¸ '; break;
                }
                
                logEntry.textContent = `[${timestamp}] ${prefix}${message}`;
                logContainer.appendChild(logEntry);
                
                // ìŠ¤í¬ë¡¤ì„ ë§¨ ì•„ë˜ë¡œ
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // ìµœëŒ€ 100ê°œ ë¡œê·¸ë§Œ ìœ ì§€
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }
            
            async quickStart() {
                try {
                    // ë§ˆì´í¬ ê¶Œí•œ í™•ì¸
                    if (!this.hasMicPermission) {
                        await this.requestMicPermission();
                        if (!this.hasMicPermission) {
                            return;
                        }
                    }
                    
                    // ì›¹ì†Œì¼“ ì—°ê²°
                    if (!this.isConnected) {
                        await new Promise((resolve, reject) => {
                            this.connectWebSocket();
                            
                            const checkConnection = () => {
                                if (this.isConnected) {
                                    resolve();
                                } else if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
                                    reject(new Error('ì—°ê²° ì‹¤íŒ¨'));
                                } else {
                                    setTimeout(checkConnection, 100);
                                }
                            };
                            
                            setTimeout(checkConnection, 100);
                            setTimeout(() => reject(new Error('ì—°ê²° ì‹œê°„ ì´ˆê³¼')), 5000);
                        });
                    }
                    
                    // ë…¹ìŒ ì‹œì‘
                    await this.startRecording();
                    
                } catch (error) {
                    console.error('ì›í´ë¦­ ì‹œì‘ ì˜¤ë¥˜:', error);
                    this.updateStatus('disconnected', 'ì›í´ë¦­ ì‹œì‘ ì‹¤íŒ¨: ' + error.message);
                }
            }
            
            updateButtonStates() {
                // ë§ˆì´í¬ ê¶Œí•œ ë²„íŠ¼
                const micPermissionBtn = document.getElementById('micPermissionBtn');
                micPermissionBtn.disabled = this.hasMicPermission;
                
                // ì›¹ì†Œì¼“ ì—°ê²° ë²„íŠ¼
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                connectBtn.disabled = !this.hasMicPermission || this.isConnected;
                disconnectBtn.disabled = !this.isConnected;
                
                // ë…¹ìŒ ë²„íŠ¼
                const startRecordingBtn = document.getElementById('startRecordingBtn');
                const stopRecordingBtn = document.getElementById('stopRecordingBtn');
                const quickStartBtn = document.getElementById('quickStartBtn');
                
                startRecordingBtn.disabled = !this.isConnected || this.isRecording;
                stopRecordingBtn.disabled = !this.isRecording;
                quickStartBtn.disabled = this.isRecording;
            }
            
            handleWebSocketMessage(data) {
                console.log('ìˆ˜ì‹  ë°ì´í„°:', data);
                
                if (data.type === 'transcription') {
                    this.displayTranscription(data);
                } else if (data.type === 'connected') {
                    console.log('ì—°ê²° í™•ì¸:', data.message);
                } else if (data.type === 'error') {
                    console.error('ì„œë²„ ì˜¤ë¥˜:', data.message);
                    alert('ì„œë²„ ì˜¤ë¥˜: ' + data.message);
                }
            }
            
            displayTranscription(data) {
                const container = document.getElementById('transcriptions');
                
                const transcDiv = document.createElement('div');
                transcDiv.className = 'transcription';
                
                const speedClass = `speed-${data.speech_metrics?.speed_category || 'normal'}`;
                const patternLabel = this.getSpeechPatternLabel(data.speech_metrics?.speech_pattern);
                
                // ê°ì •ë¶„ì„ ê²°ê³¼ HTML ìƒì„±
                let emotionHtml = '';
                if (data.emotion_analysis) {
                    const primaryEmotion = data.emotion_analysis.primary_emotion;
                    const allEmotions = data.emotion_analysis.all_emotions || data.emotion_analysis.top_emotions;
                    
                    emotionHtml = `
                        <div style="margin-top: 10px; padding: 10px; background: #f0f9ff; border-left: 4px solid #0ea5e9; border-radius: 6px;">
                            <div style="margin-bottom: 8px;">
                                <strong>ğŸ˜Š ê°ì •ë¶„ì„:</strong> 
                                <span style="font-weight: bold; color: #0369a1;">${primaryEmotion.emotion_kr}</span>
                                <span style="margin-left: 8px; padding: 2px 6px; background: #bae6fd; border-radius: 8px; font-size: 11px; font-weight: bold;">
                                    ${(primaryEmotion.probability * 100).toFixed(1)}%
                                </span>
                            </div>
                            <div style="font-size: 12px; color: #475569; margin-bottom: 8px;">
                                <strong>ëª¨ë“  ê°ì •:</strong> ${allEmotions.map(e => 
                                    `${e.emotion_kr} (${(e.probability * 100).toFixed(1)}%)`
                                ).join(', ')}
                            </div>
                            <div style="font-size: 11px; color: #64748b; margin-top: 4px;">
                                ëª¨ë¸: ${data.emotion_analysis.model_used?.split('/').pop() || 'ì•Œ ìˆ˜ ì—†ìŒ'} | 
                                ì²˜ë¦¬ì‹œê°„: ${(data.emotion_analysis.processing_time * 1000).toFixed(0)}ms |
                                ì‹œë‚˜ë¦¬ì˜¤ ê°€ì¤‘ì¹˜: ${data.emotion_analysis.scenario_applied ? 'ì ìš©' : 'ë¯¸ì ìš©'}
                            </div>
                        </div>
                    `;
                } else {
                    emotionHtml = `
                        <div style="margin-top: 10px; padding: 8px; background: #fef3c7; border-left: 4px solid #f59e0b; border-radius: 6px;">
                            <span style="font-size: 12px; color: #92400e;">ğŸ˜” ê°ì •ë¶„ì„ ê²°ê³¼ ì—†ìŒ (ì„œë¹„ìŠ¤ ì—°ê²° í™•ì¸ í•„ìš”)</span>
                        </div>
                    `;
                }
                
                transcDiv.innerHTML = `
                    <div>
                        <strong>ğŸ“ ì¸ì‹ ê²°ê³¼:</strong> ${data.text}
                        <span class="speed-category ${speedClass}">${this.getSpeedLabel(data.speech_metrics?.speed_category)}</span>
                        <span class="speech-pattern" style="margin-left: 10px; padding: 4px 8px; background: #e2e8f0; border-radius: 12px; font-size: 12px; font-weight: bold;">${patternLabel}</span>
                    </div>
                    ${emotionHtml}
                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                        ì‹œë‚˜ë¦¬ì˜¤: ${data.scenario} | ì–¸ì–´: ${data.language} | ${data.is_final ? 'ìµœì¢…' : 'ì¤‘ê°„'} ê²°ê³¼
                        ${data.segments ? ` | ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜: ${data.segments.length}` : ''}
                    </div>
                    ${this.renderMetrics(data.speech_metrics, data.syllable_metrics, data.variability_metrics, data.emotion_analysis)}
                `;
                
                container.appendChild(transcDiv);
                container.scrollTop = container.scrollHeight;
            }
            
            renderMetrics(speechMetrics, syllableMetrics, variabilityMetrics, emotionAnalysis) {
                if (!speechMetrics) return '';
                
                let emotionMetricsHtml = '';
                if (emotionAnalysis && (emotionAnalysis.all_emotions || emotionAnalysis.top_emotions)) {
                    const emotions = emotionAnalysis.all_emotions || emotionAnalysis.top_emotions;
                    emotionMetricsHtml = emotions.map(emotion => `
                        <div class="metric-card">
                            <div class="metric-value">${emotion.emotion_kr}</div>
                            <div class="metric-label">${(emotion.probability * 100).toFixed(1)}%</div>
                        </div>
                    `).join('');
                }
                
                return `
                    <div class="metrics">
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.evaluation_wpm}</div>
                            <div class="metric-label">í‰ê°€ WPM</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.average_segment_wpm}</div>
                            <div class="metric-label">ì„¸ê·¸ë¨¼íŠ¸ í‰ê·  WPM</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.median_segment_wpm}</div>
                            <div class="metric-label">ì„¸ê·¸ë¨¼íŠ¸ ì¤‘ì•™ê°’ WPM</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${(speechMetrics.speech_density * 100).toFixed(1)}%</div>
                            <div class="metric-label">ë°œí™” ë°€ë„</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.pause_metrics?.count || 0}</div>
                            <div class="metric-label">Pause íšŸìˆ˜</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.pause_metrics?.average_duration?.toFixed(2) || 0}ì´ˆ</div>
                            <div class="metric-label">í‰ê·  Pause</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${this.getSpeechPatternLabel(speechMetrics.speech_pattern)}</div>
                            <div class="metric-label">ë§í•˜ê¸° íŒ¨í„´</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value">${speechMetrics.wpm_cv || 0}</div>
                            <div class="metric-label">WPM ë³€ë™ì„±</div>
                        </div>
                        ${syllableMetrics ? `
                        <div class="metric-card">
                            <div class="metric-value">${syllableMetrics.spm_active}</div>
                            <div class="metric-label">SPM (ë°œí™”ì‹œ)</div>
                        </div>` : ''}
                        ${emotionMetricsHtml}
                    </div>
                `;
            }
            
            getSpeedLabel(category) {
                const labels = {
                    'very_slow': 'ë§¤ìš° ëŠë¦¼',
                    'slow': 'ëŠë¦¼',
                    'normal': 'ì ë‹¹',
                    'fast': 'ë¹ ë¦„',
                    'very_fast': 'ë§¤ìš° ë¹ ë¦„',
                    'no_data': 'ë°ì´í„° ì—†ìŒ'
                };
                return labels[category] || 'ì•Œ ìˆ˜ ì—†ìŒ';
            }
            
            getSpeechPatternLabel(pattern) {
                const labels = {
                    'staccato': 'ëŠì–´ ë§í•˜ê¸°',
                    'continuous': 'ì—°ì†ì ',
                    'very_sparse': 'ë§¤ìš° ë„ì—„ë„ì—„',
                    'steady': 'ì¼ì •í•œ ì†ë„',
                    'variable': 'ì†ë„ ë³€í™” í¼',
                    'normal': 'ì¼ë°˜ì ',
                    'no_data': 'ë°ì´í„° ì—†ìŒ'
                };
                return labels[pattern] || 'ì•Œ ìˆ˜ ì—†ìŒ';
            }
            
            async uploadFile() {
                const fileInput = document.getElementById('fileInput');
                const file = fileInput.files[0];
                
                if (!file) {
                    alert('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                const formData = new FormData();
                formData.append('audio_file', file);
                
                const language = document.getElementById('languageSelect').value;
                const url = `http://localhost:8000/api/v1/stt/transcribe?scenario=${this.currentScenario}&language=${language}&return_timestamps=true`;
                
                try {
                    this.updateStatus('recording', 'íŒŒì¼ ë¶„ì„ ì¤‘...');
                    this.addLog('send', `íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`);
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        this.addLog('receive', `íŒŒì¼ ë¶„ì„ ì™„ë£Œ: "${result.text?.substring(0, 50)}${result.text?.length > 50 ? '...' : ''}"`);
                        this.displayFileResult(result);
                        this.updateStatus('connected', 'ë¶„ì„ ì™„ë£Œ');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.error('íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë¥˜:', error);
                    this.addLog('info', `íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë¥˜: ${error.message}`);
                    alert('íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    this.updateStatus('disconnected', 'ë¶„ì„ ì‹¤íŒ¨');
                }
            }
            
            displayFileResult(data) {
                const container = document.getElementById('transcriptions');
                
                const resultDiv = document.createElement('div');
                resultDiv.className = 'transcription';
                
                resultDiv.innerHTML = `
                    <div>
                        <strong>ğŸ“ íŒŒì¼ ë¶„ì„ ê²°ê³¼:</strong> ${data.text}
                    </div>
                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                        ì–¸ì–´: ${data.language} | ì²˜ë¦¬ ì‹œê°„: ${data.processing_time?.toFixed(2)}ì´ˆ | ì˜¤ë””ì˜¤ ê¸¸ì´: ${data.duration?.toFixed(2)}ì´ˆ
                    </div>
                `;
                
                container.appendChild(resultDiv);
                container.scrollTop = container.scrollHeight;
            }
            
            updateStatus(type, message) {
                const statusEl = document.getElementById('status');
                statusEl.className = `status ${type}`;
                statusEl.textContent = message;
            }
        }
        
        // í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
        const client = new RealtimeSTTClient();
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸° ìƒíƒœ ì„¤ì •
        window.addEventListener('load', () => {
            client.updateButtonStates();
        });
    </script>
</body>
</html> 